#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           MBRDrive,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           FLDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           MFLDrive,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           MBLDrive,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BLDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           FRDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           MFRDrive,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           ConveyorMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           MobileGoalMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BRDrive,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "gyroLib2.c";

//VARIABLES
int maxSpeed = 127;
float kP = .04;
float kI = 0.000001;
float kD = 0;
float kC = 1;

float kP_turn = 1.2;
float kI_turn = .001;
float kD_turn = 0;

float error, drivePower, sumError, driftError, driftCorrection;
float MAX_INTEGRAL_VALUE = 50;
float integralActiveZone = 0.0;
float gyroDegrees = 0;

//FORWARD DECLARATIONS
float inchesToTicks(float inches);
void RightDrive(int speed);
void LeftDrive(int speed);
void pidDriveLoop(float targetTicks);
void pidTurnLoop(float targetDegrees, int direction);

task printGyroValues
{
  while(true)
  {
    if(GyroValidGet())
    {
      gyroDegrees = GyroAngleDegGet();
      writeDebugStreamLine("Degree: %d", gyroDegrees);
    }
  	wait1Msec(20);
  }
}

task bringMobileGoalDown
{
	motor[MobileGoalMotor] = maxSpeed;
	wait1Msec(500);
	motor[MobileGoalMotor] = 0;
}

task bringMobileGoalUp
{
	motor[MobileGoalMotor] = -maxSpeed;
	wait1Msec(1410);
	motor[MobileGoalMotor] = 0;
}

task initialDrive
{
	pidDriveLoop(inchesToTicks(30.0));
}

task secondaryDrive
{
	pidDriveLoop(inchesToTicks(40.0));
}

task tertiaryDrive
{
	pidDriveLoop(inchesToTicks(29.0));
}

task quadraryDrive
{
	pidDriveLoop(inchesToTicks(15.0));
}

task bringConveyorBack
{
	motor[ConveyorMotor] = maxSpeed;
	wait1Msec(1300);
	motor[ConveyorMotor] = 0;
}

task firstTurn
{
  kP_turn = 2.0;
	pidTurnLoop(45.0, 0);
}

//MAIN
task main()
{
	GyroInit();
  SensorType[in1] = sensorNone;
  wait1Msec(1000);
  SensorType[in1] = sensorGyro;
  wait1Msec(1000);
 	startTask(printGyroValues);
	//startTask(bringMobileGoalDown);
 // wait1Msec(1000);
 // stopTask(bringMobileGoalDown);
 	startTask(initialDrive);
 	wait1Msec(2500);
 	stopTask(initialDrive);
 	LeftDrive(0);
 	RightDrive(0);
 // startTask(bringMobileGoalUp);
 // wait1Msec(1000);
	//startTask(bringConveyorBack);
	//wait1Msec(1500);
	//startTask(bringMobileGoalDown);
	//wait1Msec(1500);
	//startTask(secondaryDrive);
	//wait1Msec(3000);
	//stopTask(secondaryDrive);
	//LeftDrive(0);
	//RightDrive(0);
	//startTask(bringMobileGoalUp);
	//wait1Msec(1500);
	//startTask(tertiaryDrive);
	//wait1Msec(3000);
	startTask(firstTurn);
	wait1Msec(1500);
	stopTask(firstTurn);
	//startTask(quadraryDrive);
	//wait1Msec(3000);
	//stopTask(quadraryDrive);
	//wait1Msec(10000);
}

//METHODS
float inchesToTicks(float inches)
{
	return ((64.0/36.0)*(inches/(3.25*PI))*360.0);
}

void RightDrive(int speed)
{
	motor[FRDrive] = speed;
	motor[MFRDrive] = speed;
	motor[MBRDrive] = speed;
	motor[BRDrive] = speed;
}

void LeftDrive(int speed)
{
	motor[FLDrive] = speed;
	motor[MFLDrive] = speed;
	motor[MBLDrive] = speed;
	motor[BLDrive] = speed;
}
void pidDriveLoop(float targetTicks)
{
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
	error = drivePower = sumError = driftError = driftCorrection = integralActiveZone = 0;
	integralActiveZone = targetTicks * .125;

	while(SensorValue[RightEncoder] != targetTicks)
	{
		//Limit drive power
		if(drivePower > maxSpeed)
		{
			drivePower = maxSpeed;
		}
		if(drivePower < -maxSpeed)
		{
			drivePower = -maxSpeed;
		}

		//Proportional
		error = targetTicks - SensorValue[RightEncoder];

		//Integral
		if (abs(error) < inchesToTicks(integralActiveZone))
		{
			sumError += error;
		}
		else
		{
			sumError = 0;
		}

		if ((sumError*kI) > MAX_INTEGRAL_VALUE)
		{
			sumError = MAX_INTEGRAL_VALUE / kI;
		}

		//Derivative

		//Drift correction
		driftError = SensorValue[RightEncoder] - SensorValue[LeftEncoder];
		driftCorrection = driftError * kC;

		drivePower = kP * error + kI * sumError;

		RightDrive(drivePower - driftCorrection);
		LeftDrive(drivePower + driftCorrection);
	}
}

void pidTurnLoop(float targetDegrees, int direction)
{
	//error = drivePower = sumError = driftError = driftCorrection = integralActiveZone = 0;
	setGyroAngle(0.0);
	integralActiveZone = 0.125 * targetDegrees;

	//Turn Left
	if (direction == 0)
	{

		while (GyroAngleDegGet() < targetDegrees)
		{
			//Limit drive power
			if (drivePower > maxSpeed)
			{
				drivePower = maxSpeed;
			}
			if (drivePower < -maxSpeed)
			{
				drivePower = -maxSpeed;
			}

			//Proportional
			error = targetDegrees - GyroAngleDegGet();

			//Integral
			if (error < integralActiveZone)
			{
				sumError += error;
			}
			if (error > integralActiveZone)
			{
				sumError = 0;
			}
			if ((sumError * kI_turn) > MAX_INTEGRAL_VALUE)
			{
				sumError = MAX_INTEGRAL_VALUE / kI_turn;
			}

			//Derivative

			//Set motor power
			drivePower = kP_turn * error + kI_turn * sumError;
			LeftDrive(-drivePower);
			RightDrive(drivePower);
			}
		}

		//Turn Right
		if (direction == 1)
		{
			SensorValue[gyro] = 3590;

			while (GyroAngleDegGet() > (359 - targetDegrees))
			{
				//Limit drive power
				if (drivePower > maxSpeed)
				{
					drivePower = maxSpeed;
				}
				if (drivePower < -maxSpeed)
				{
					drivePower = -maxSpeed;
				}

				//Proportional
				error = targetDegrees - GyroAngleDegGet();

				//Integral
				if (error < integralActiveZone)
				{
					sumError += error;
				}
				if (error > integralActiveZone)
				{
					sumError = 0;
				}
				if ((sumError * kI_turn) > MAX_INTEGRAL_VALUE)
				{
					sumError = MAX_INTEGRAL_VALUE / kI_turn;
				}

				//Derivative

				//Set motor power
				drivePower = kP_turn * error + kI_turn * sumError;
				LeftDrive(-drivePower);
				RightDrive(drivePower);
			}
		}

		wait1Msec(500);
}
